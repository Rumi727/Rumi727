# Runiverse OS

루미의(나의) 캐릭터 세계관\
버전 : v0.1.2\
약칭 : ROS, RuniOS

---

루미가 창조한 운영체제 세계.

현재는 아무것도 없지만, 시간이 지나면 크게 발전할 것이라고 루미는 믿고 있다.

## 설명

* **오너 캐릭터**가 자신이 평소에 지낼 공간이 필요하여 이 세계를 창조했다.
* 평범한 세계와는 다르게 현실의 운영체제랑 똑같은 구조로 흘러간다.
  * 즉, 이 세계는 **운영체제**이다.
    * 이 글 이후로는 앞으로 이 세계를 **운영체제**라고 칭한다.
  * 중앙 처리 장치와 커널은 **오너 캐릭터가** 담당하며 커널의 권한은 절대적이므로 (Ring 0) 내부적으론 커널보다 권한이 높은 건 존재하지 않는다.
    * 다만 이는 내부의 권한이기에 외부로 넘어가면 커널보다 권한이 높을 수 있다.
      * 예를 들어서, 이 RuniOS 운영체제가 현실의 윈도우 내부에 **직접** 들어갔을 경우 윈도우의 (정확힌 CPU) 입장에서 RuniOS 운영체제는 Ring 3으로 실행되는 것이다.
      * 그렇기에 RuniOS가 현실의 윈도우 내부에 **직접** 들어갔을 경우는, 윈도우에서 시스템 콜을 호출해야하며 직접 메모리를 조작할 수 없게 된다.
      * 하지만 파훼법이 있는데 RuniOS 운영체제 전체가 현실의 윈도우 내부에 **직접** 들어가는게 아니라 현실의 윈도우를 RuniOS 운영체제 내부로 넣거나(!), 아니면 그냥 **현실 조작**으로(!!) 파훼할 수 있다.
    * 그렇기에 바이오스 같은 권한이 커널보다 높은 시스템은 (Ring 0 보다 낮은 단계는) 내부에 존재하지 않는다. 내부적으론 구조상 항상 커널이 권한이 제일 높다.
    * 당연히 모든걸 의식으로 처리하진 않는다. 모든 명령은 기본적으로 기계적인 무의식으로 처리하되, 필요시 (또는 원할시) 의식이 들어간다.
      * 모든 시스템 콜과 IL 코드를 무의식으로 처리하기 위해 **현실 조작으로 자기 자신을 조작했다**.
      * 혹시 오해할 수 있어서 덧붙이자면 RuniOS 운영체제는 **시스템 콜 자채가 CPU 명령어의 일종이다.** (루미가 CPU이기 때문인데, 루미에게 직접적으로 운영체제 명령을 내리는게 후술할 C#의 RuniOS.SystemCallAttribute 어트리뷰트가 지금으로썬 유일하다.)
* C# 기반이다
  * ``RuniOS.SystemCallAttribute`` 어트리뷰트가 있으며, 이 어트리뷰트는 오너캐 <-> C# 처럼 서로 쉽게 상호작용할 수 있게 도와준다.
    * 멤버 목록
      * ``public string command { get; }``
        * 커널이 이 멤버가 무슨 명령을 처리해야하는지 알 수 있게끔 문자열을 지정 하면 된다.
        * 오너캐는 평범하게 필드의 위치를 적지만, 일단 커널을 관리하는 오너캐는 지적 생명체이기에 한국어나 영어 같은거 적어도 잘 알아먹는다.
     * 생성자 : ``public SystemCallAttribute(string command) => this.command = command;``
  * ``RuniOS.BigComplex`` 구조체가 있으며, 이 구조체는 한치의 오차도 없는 **매우 정확한 복소수**를 저장하고 계산할 수 있다.
    * 참고로 일종의 계산기 역할도 하는데, 미친 만능이라 무리수, 극한, 미적분, 방정식,  **심지어는 소수마저** (2, 3, 5, 7 할 때 그 소수 맞다) 원하는 모든 계산을 완벽하게 한치의 오차도 없이 바로 계산한다.
    * 다시 말하는데 **구조체다**.
    * 모든 연산을 원자적으로 처리한다. (Thread-safe)
  * ``RuniOS.AnalogConverter`` 정적 클래스가 있으며, 이 클래스는 **아날로그와 디지털을 상호변환하는** 매우 중요한 역할을 수행한다.
    * 이 클래스가 없다면 루미를 제외한 **모든 물질과 생명체는 운영체제에 들어갈 수 조차 없다.** (그야 운영체제는 디지털이고, 디지털 생명체라고 해도 운영체제에 맞게 변환해주긴 해야하니까)
    * 멤버 목록
      * ``[RuniOS.SystemCall("RuniOS.AnalogConverter.GetSubstance(string)")] public static extern unsafe void* GetSubstance(string command);``
        * 원하는 물질을 포인터로 참조하고 반환한다.
      * ``[RuniOS.SystemCall("RuniOS.AnalogConverter.ToDigital(void*)")] public static extern unsafe RuniOS.Process ToDigital(void* substance);``
        * 알 수 없는 물질을 포인터로 전달하여 루미가 디지털로 그 값을 Process 클래스로 만들어 반환한다. (소멸 -> 생성의 단계가 아니다. **변환이다.**, 매우 안전하게 진행되며 BigComplex의 도움으로 오차는 전혀 없다.)
      * ``[RuniOS.SystemCall("RuniOS.AnalogConverter.ToDigital(RuniOS.Progress)")] public static extern unsafe void ToAnalog(Process process);``
        * 프로세스를 다시 아날로그로 변환한다.
  * ``RuniOS.Process`` 안전하지 않은 (unsafe) **추상** 클래스가 있으며, 이 클래스는 프로세스에 대한 **모든 정보를** 가지고 관리하는 매우 중요한 역할을 수행한다.
    * ``System.Reflection.Emit.TypeBuilder`` 클래스 등을 사용하여 프로세스마다 ``RuniOS.Process`` 클래스와 여러 인터페이스를 상속 받은 적절한 타입을 동적으로 생성한다. 
    * 멤버 목록
      * ``public static System.Collection.Generic.IReadOnlyList<RuniOS.Process> processes { get; }``
        * 운영체제에 로드된 모든 프로세스 목록을 가져온다.
      * ``public void* substance { get; }``
        * 메모리상에서 물질에 대한 모든 데이터를 가지고 있는 위치를 가리키는 포인터이다.
        * 이렇게 노출되면 위험하지 않냐고 생각할 수 있지만, 안전하다. 포인터가 가르키는 메모리 위치는 Ring 0만 접근할 수 있게 보호된 위치이기 때문이다.
      * ``public System.Numerics.BigInteger id { get; }``
        * 프로세스의 고유 id이다. 별건 없다. 그냥 뭔가 있어야할 것 같음ㅋㅋㅋㅋㅋ
      * 프로세스는 물질에 따라 적절한 인터페이스를 동적으로 상속한다.
        * 예를 들어서 현실의 우주에서 온 물질이라면 ``IUniverse`` 인터페이스를 상속할 것 입니다.
        * 그런 인터페이스는 꽤나 유용할 수 있는데, 예를 들어 ``IHuman`` 인터페이스는 nationality, name, birthday, biologicalSex, position 같은 유용한 프로퍼티를 노출하며, 이는 루미가 물질 값에서 (substance) 적절히 가져와서 계산하여 랩핑한 것이다.
          * RuniOS 운영체제의 예시 클래스 다이어그램은 밑에 있습니다!
  * Runi OS 운영체제의 예시 [클래스 다이어그램](https://raw.githubusercontent.com/Rumi727/Rumi727/refs/heads/main/Runiverse/Runiverse%20OS%20Class%20Designer/ClassDiagram.png)
* 현실 사람 또는 현실 그 자채, 아니면 특정 세계관의 캐릭터 또는 세계관 그 자채를 운영체제로 불러올 수 있다.
  * 오너캐는 이를 ``프로세스``라고 부른다.
  * 오너캐 또한 프로세스로 취급하긴 하다.
    * 다만 운영체제에 종속되지 않는 오너캐의 특성상 일반적인 프로세스랑은 다른 특수 프로세스라 언로드가 이론상으로도 불가능하다.
  * 아, 운영체제라는 이름의 걸맞게 그 세계에 존재하는 프로그램 조차도 실행할 수 있다. (Ring 3으로 실행하며, 시스템 콜은 알맞게 변환된다.)
    * 윈도우 프로그램이던 맥 프로그램이던 안드로이드 앱이던 심지어는 이세계 앱 조차 다 가능하다.
    * 게임의 경우 운영체제의 특성상 프레임 제한이 없다면 샐 수 없을 정도로 높은, 사실상 무제한인 프레임으로 게임을 할 수 있을 것이다.
* 주 기억 장치의 용량은 **무한하다**.
  * ``RuniOS.BigComplex`` 타입이 존재할 수 있는 이유이기도 하다.
  * 보조 기억 장치는 기본적으로 없지만 외부 장치를 연결할 수는 있다. (있어도 의미 없음)
* 운영체제의 대한 Life-cycle이자 틱, 즉 시간 흐름은 오너캐가 관리한다.
  * 틱과 틱 사이의 시간은 델타타임이라하며, 이 운영체제에선 일반적으로 값은 플랑크 시간이다. (플랑크 시간 = ``5.391247(60) * (10^-44)[s]``)
  * 델타타임은 오너캐가 입맛대로 바꿀 수 있다.
* 기본적으로 총 4개의 스레드가 존재한다.
  * 따로 예외 사항이 적혀있지 않는 한 여기에 적힌 모든 스레드는 운영체제의 Life-cycle에 종속된다.
    * 실행 된 직후 무한히 반복하며  예외가 나도 정지하지 않는다. (오너캐가 임의로 변경할 수 있다.)
    * 코드로 표현하면 ``while (true) { try { /* code */ } catch { /* logging code */ } }`` 이런 느낌이다.
  * Life-cycle를 관리하는 물질이 일단은 오너캐 한명 뿐이라 (CPU 코어가 하나라) 스레드가 병렬로 실행되진 않으나, 이는 정해진것은 아니다.
  * 시간 스레드
    * ``Thread.Sleep(int)`` 같은 정지 함수나 시간 관련 코드를 처리하기 위해 존재한다.
    * 이 스레드는 ``RuniOS.Time`` 정적 클래스에서 실행되며, 또한 이 클래스의 모든 연산은 원자적으로 처리한다. (Thread-safe)
    * ``Rumi.Time`` 클래스의 멤버 목록
      * ``public static extern RuniOS.BigComplex time { [RuniOS.SystemCall("RuniOS.Time.time")] get; }``
        * 1970년 1월 1일 00:00:00 협정 세계시 부터의 경과 시간을 초로 환산하여 실수로 나타낸 값이다. 윤초는 무시된다. (유닉스 시간이랑 똑같은 것처럼 보이지만 유닉스 시간은 정수라 다르다.)
      * ``public static extern RuniOS.BigComplex deltaTime { [RuniOS.SystemCall("RuniOS.Time.deltaTime")] get; }``
        * 틱과 틱 사이의 시간, 즉 델타타임을 반환한다. **(한치의 오차도 없이 매우 정확한 값이다.)**
    * ``Thread.Sleep(int)`` 같은 시간 기준으로 정지하는 코드는 일반적으론 ``time`` 프로퍼티의 값을 사용한다
  * 메인 스레드
    * 운영체제의 일반적인 코드를 처리하는 스레드이다.
  * 명령 스레드
    * 일단 Life-cycle에 포함되긴 하지만, 일반적으론 스레드 동시 접근을 피하기 위해 모든 스레드의 연산이 끝났을때 명령을 처리한다.
    * 오너캐 또는 권한을 받은 물질이 직접 내리는 명령을 처리하는 스레드이다.
      * 그렇기에, 이 스레드는 실행하는 코드가 매 틱마다 달라질 수 있다.
  * 렌더링 스레드
    * 운영체제를 포함한 모든 프로세스를 3D 렌더링하여 디지털 생명체가 볼 수 있도록 세계에 출력하며, 아날로그 세계에서도 볼 수 있도록 출력물을 특정한 에너지로 (현실에선 빛 에너지) 변환하는 스레드이다.
    * 프로그램의 경우 후술할 창 관리자가 관리하며, 지원하는 프로그램의 경우 2D 렌더링이 아닌 **3D로 렌더링** 할 수 있다.
       * 예를 들어... 원신을 켰다고 하면 그걸 2D 화면이 아닌 사실적인 3D로 볼 수 있다던가?
       * ~~오늘도 오너캐는 이를 지원하는 프로그램을 늘리기 위해 갈려나갑니다...~~
  * 이외에도 커널이 필요하다면 스레드가 더 생성될 수 있다.
* 이 운영체제가 실행한 모든 내부 명령은 **실행 즉시** 완료된다.
  * 다만 **인터넷 같은 운영체제 외부에 접근** 하는 경우 같은 시간에 영향받을 수 밖에 코드가 있을 경우, 비동기 처리를 하지 않았다면 그 코드의 처리가 끝날 때 까지 운영체제 전체가 일시 중지한다.
    * 운영체제의 외부이기에 운영체제 안에 로드시켰다면 이는 외부가 아니다.
* 커널이 외부의 하드웨어(예: 현실의 컴퓨터)에 접근하여 화면 및 소리 등등을 출력하거나 그 하드웨어가 운영체제를 조작할 수 있게 하는 등의 권한을 자유롭게 줄 수 있다.
* 내외부에서 만들어지거나 실행된 GUI 프로그램에 대한 창을 관리하는 창 관리자가 있다.
  * 테마 시스템이 있다.
  * 외부 세계의 운영체제에서 (리눅스나 윈도우즈같은) 실행된 프로그램이라 해도, 창 관리자가 그것을 후킹하여 자채적인 창 관리를 수행한다.
    * 이때는 프로그램의 렌더링을 운영체제 내부에서 새로하며, 그렇기에 창 크기를 자유롭게 조절하거나 크로마키와 마스크를 씌우는 등 고급 렌더링을 할 수 있으며 지원하는 경우 3D 렌더링 또한 가능하다.
    * 물론, 얘기했듯이 운영체제 내부에서 렌더링을 새로 하는 것이기에 외부 세계에는 전혀 영향 받지 않는다. ~~다만 후킹 형식으로 렌더링을 가로채는거라 안티치트엔 걸릴 수도?~~
  * 호환성 모드를 활성화 하면, 창 관리를 수행하지 않기에 테마, 3D 렌더링, 창 크기 조절 같은것을 사용하지 못하나, 외부에서 렌더링 한 결과물을 그대로 운영체제로 출력하기에 호환성은 제일 좋다.
    * 예를 들어서 현실의 리눅스에서 실행된 프로그램을 호환성 모드로 불러왔다면, 리눅스에서 렌더링 된 창 자채를 있는 그대로 출력하여 창이 리눅스 테마로 보일 것이다.
  * 외부 세계의 운영체제에서 만들어졌지만, 실행 주체가 외부 세계의 운영체제가 아닌 내부 운영체제일 경우 어차피 운영체제 코드를 거치기에 후킹을 하지 않아도 되어 호환성 문제 또한 발생하지 않는다.

``RuniOS.SystemCallAttribute`` 사용 예시
```cs
using System;
using RuniOS;

/*
 * 커널은 일반적으론 평범한 메소드에 붙었을때 "Start", "Init" 같은 값이 메소드 이름이거나 입력되었다면 이를 명령 스레드에서 딱 한번 메소드를 실행한다.
 * 반대로 "Update", "Loop" 같은 값이 입력되면 운영체제의 Life-cycle에 종속되어 사용자나 커널이 취소할 때 까지 명령 스레드에서 틱 당 한번씩 무한히 실행한다.
 * 만약 extren 함수가 아니고, 클래스의 멤버이지만 정적 멤버는 아닐 경우엔 인스턴스가 생성될 때 실행한다.
 */
[SystemCall("Start")]
void WaSans()
{
  Console.WriteLine(calc);
  Console.WriteLine(OwnerInvoke());
  Shutdown();
}

// 커널은 일반적으론 입력된 값이나 멤버 이름에 맞는 값을 반환하려 노력한다.
static extern double calc { [SystemCall("532.513 * 153.425 / 6341")] get; }
[SystemCall("놀아주라")] static extern string OwnerInvoke();

// 사용자한태 꼭 결과값을 알려줘야하거나 명령을 실행하는데 실패 했을 경우 (명령을 이해하지 못했거나 권한이 없다거나 등) 예외로 처리한다.
[SystemCall("shutdown")] static extern void Asdf();
```
```cs
/* 출력

12.8845303619303
루미두 놀고 싶지만... 지금은 마니 바빠..!

Unhandled exception. System.OperationCanceledException: 그리고.. 이건 무엇을 하고 싶은거야..?
   at Submission#0.<WaSans>d__0() in <8d5cc6388a0d2b4bdbcc56aadf0e80d7>:line 10
   at Submission#0.<Factory0>(Object $host, Object[] $args) in <8d5cc6388a0d2b4bdbcc56aadf0e80d7>:line 0

*/
```
... 사실 웬만하면 오너캐한태 ~~직접 가서 말하는게 더 나을 것이다.~~ 코드에서 오너캐의 능력이 필요한 것은 꽤 보기 드물 것\
보통 코드로 커널한태 접근할 수 있는 권한을 얻었다면, 그 전에 이미 오너캐랑 한번 이상은 만났을 것이기 때문\
그냥 이런 것도 있다~ 하는 정도?

## 세계관 혼합의 공식적인 예시

운영체재의 커널, 즉 루미라는 캐릭터는, 거의 대부분의 세계관에서 최강자로 의도된 캐릭터이지만, 저는 다른 세계관의 설정을 존중하고싶습니다.\
이에, 서로 다른 세계관을 병합할 때 병합 충돌이 발생할 수 있는 설정들의 경우 어떤식으로 병합 충돌이 해결되는지 예시를 보려주려고 합니다.\
물론 이는 제 개인적인 의견일 뿐, 강제적으로 적용되진 않는다는 점을 참고해주세요.

추가로 ROS 소속의 캐릭터가 상호작용하고 있는 세계관의 설정은 ROS의 세계관 설정보다 **우선적으로 적용된다는 점**을 기억해주세요.\
단, 현실 조작 관련 능력을 가진 캐릭터는 현실을 **조작하는 것이기에** 자유롭게 능력을 사용할 수 있습니다.

예를 들어서, 입으로 불을 뿜을 수 있는 능력의 캐릭터가 있고, 그 캐릭터는 불이라는 개념이 존재하지 않는 세계관과 상호작용할 경우 그 캐릭터는 불을 뿜을 수 없는 허접이 될 것 입니다.\
하지만, 그 능력이 현실 조작을 기반으로 이루어진 능력이라면 무시할 수 있습니다.

현실 조작이란 개념이 없는 세계의 경우, 현실 조작으로 현실 조작이란 개념이 없는 것을 조작했다 볼 수 있기에 현실 조작이 일반적으론 더 우선 됩니다.


### SCP Foundation

* 스크랜턴 현실성 닻
  * 커널, 즉 루미의 ~~Antinfinity Teleport라고 불리는~~ 긴급 텔레포트 능력을 제외한 **모든 능력**은 **현실 조작**을 기반으로 이루어진 능력이기에, 스크랜턴 현실성 닻의 영향 범위 내에서는 모든 능력을 사용할 수 없습니다.

  * 운영체제의 내부에 설치된 경우는 좀 특이하게 동작하는데, 운영체제 내부에서의 루미의 현실 조작은 운영체제, 즉 그 세계에선 **너무나 당연한 사건**이기에 **현실 조작으로 판정되지 않습니다.**
    * 하지만, 루미의 권한을 통해 부여받은 능력으로 규칙에서 벗어난것이 아닌 현실 조작이라면, 그 사건은 실제로 현실 조작으로 간주되기에 스크랜턴 현실성 닻의 영향 범위 내에서는 능력을 사용할 수 없게 됩니다.
  * 크샹크/아나스타사코스 일정불변 시간적 특이점 또한 비슷하게 작용합니다.

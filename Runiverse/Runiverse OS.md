# Runiverse OS

루미의(나의) 캐릭터 세계관\
버전 : v0.1.3\
약칭 : ROS, RuniOS

---

루미가 창조한 운영체제 세계.

현재는 아무것도 없지만, 시간이 지나면 크게 발전할 것이라고 루미는 믿고 있다.

---

참고: 근본 없습니다. 저도 알고있지만, 수정하기 귀찮아요...\
그냥 이렇다! 라는 느낌보단 이런 느낌이다! 라고 생각하시면 될 것 같아요.

## 설명

* **오너 캐릭터**가 자신이 평소에 지낼 공간이 필요하여 이 세계를 창조했다.
* 평범한 세계와는 다르게 현실의 운영체제랑 똑같은 구조로 흘러간다.
  * 즉, 이 세계는 **운영체제**이다.
    * 이 글 이후로는 앞으로 이 세계를 **운영체제**라고 칭한다.
  * 중앙 처리 장치와 커널은 **오너 캐릭터가** 담당하며 커널의 권한은 절대적이므로 (Ring 0) 내부적으론 커널보다 권한이 높은 건 존재하지 않는다.
    * 다만 이는 내부의 권한이기에 외부로 넘어가면 커널보다 권한이 높을 수 있다.
      * 예를 들어서, 이 RuniOS 운영체제가 현실의 윈도우 내부에 **직접** 들어갔을 경우 윈도우의 (정확힌 CPU) 입장에서 RuniOS 운영체제는 Ring 3으로 실행되는 것이다.
      * 그렇기에 RuniOS가 현실의 윈도우 내부에 **직접** 들어갔을 경우는, 윈도우에서 시스템 콜을 호출해야하며 직접 메모리를 조작할 수 없게 된다.
      * 하지만 파훼법이 있는데 RuniOS 운영체제 전체가 현실의 윈도우 내부에 **직접** 들어가는게 아니라 현실의 윈도우를 RuniOS 운영체제 내부로 넣거나(!), 아니면 그냥 **현실 조작**으로(!!) 파훼할 수 있다.
    * 그렇기에 바이오스 같은 권한이 커널보다 높은 시스템은 (Ring 0 보다 낮은 단계는) 내부에 존재하지 않는다. 내부적으론 구조상 항상 커널이 권한이 제일 높다.
    * 당연히 모든걸 의식으로 처리하진 않는다. 모든 명령은 기본적으로 기계적인 무의식으로 처리하되, 필요시 (또는 원할시) 의식이 들어간다.
      * 모든 시스템 콜과 IL 코드를 무의식으로 처리하기 위해 **현실 조작으로 자기 자신을 조작했다**.
      * 혹시 오해할 수 있어서 덧붙이자면 RuniOS 운영체제는 **시스템 콜 자채가 CPU 명령어의 일종이다.** (루미가 CPU이기 때문인데, 루미에게 직접적으로 운영체제 명령을 내리는게 후술할 C#의 RuniOS.SystemCallAttribute 어트리뷰트가 지금으로썬 유일하다.)
* C# 기반이다
  * Runi OS 운영체제의 예시 [클래스 다이어그램](https://raw.githubusercontent.com/Rumi727/Rumi727/refs/heads/main/Runiverse/Runiverse%20OS%20Class%20Designer/ClassDiagram.png)
  * (C#) 멤버들의 설명을 보고싶으신 분들은 [다이어그램의 실제 프로젝트](Runiverse%20OS%20Class%20Designer)로...
  * 사실... C#과 전혀 어울리지 않는 설계 구조라는걸 깨달았어요.\
    갈아엎을 생각은 있지만, 귀찮네요... 그냥 참고용으로만 봐주세요.
* 현실 사람 또는 현실 그 자채, 아니면 특정 세계관의 캐릭터 또는 세계관 그 자채를 운영체제로 불러올 수 있다.
  * 오너캐는 이를 ``프로세스``라고 부른다.
  * 오너캐 또한 프로세스로 취급하긴 하다.
    * 다만 운영체제에 종속되지 않는 오너캐의 특성상 일반적인 프로세스랑은 다른 특수 프로세스라 언로드가 이론상으로도 불가능하다.
  * 아, 운영체제라는 이름의 걸맞게 그 세계에 존재하는 프로그램 조차도 실행할 수 있다. (Ring 3으로 실행하며, 시스템 콜은 알맞게 변환된다.)
    * 윈도우 프로그램이던 맥 프로그램이던 안드로이드 앱이던 심지어는 이세계 앱 조차 다 가능하다.
    * 게임의 경우 운영체제의 특성상 프레임 제한이 없다면 샐 수 없을 정도로 높은, 사실상 무제한인 프레임으로 게임을 할 수 있을 것이다.
* 주 기억 장치의 용량은 **무한하다**.
  * 보조 기억 장치는 기본적으로 없지만 외부 장치를 연결할 수는 있다. (있어도 의미 없음)
* 운영체제를 포함한 모든 프로세스를 3D 렌더링하며, 또한 특정한 에너지로도 출력하여 (현실에선 빛 에너지) 실제로 볼 수 있게 한다.
  * 프로그램의 경우 후술할 창 관리자가 관리하며, 지원하는 프로그램의 경우 2D 렌더링이 아닌 **3D로 렌더링** 할 수 있다.
    * 예를 들어... 원신을 켰다고 하면 그걸 2D 화면이 아닌 사실적인 3D로 볼 수 있다던가?
    * ~~오늘도 오너캐는 이를 지원하는 프로그램을 늘리기 위해 갈려나갑니다...~~
* 이 운영체제가 실행한 모든 내부 명령은 **실행 즉시** 완료된다.
  * 다만 **인터넷 같은 운영체제 외부에 접근** 하는 경우 같은 시간에 영향받을 수 밖에 코드가 있을 경우, 비동기 처리를 하지 않았다면 그 코드의 처리가 끝날 때 까지 운영체제 전체가 일시 중지한다.
    * 운영체제의 외부이기에 운영체제 안에 로드시켰다면 이는 외부가 아니다.
* 커널이 외부의 하드웨어(예: 현실의 컴퓨터)에 접근하여 화면 및 소리 등등을 출력하거나 그 하드웨어가 운영체제를 조작할 수 있게 하는 등의 권한을 자유롭게 줄 수 있다.
* 내외부에서 만들어지거나 실행된 GUI 프로그램에 대한 창을 관리하는 창 관리자가 있다.
  * 테마 시스템이 있다.
  * 외부 세계의 운영체제에서 (리눅스나 윈도우즈같은) 실행된 프로그램이라 해도, 창 관리자가 그것을 후킹하여 자채적인 창 관리를 수행한다.
    * 이때는 프로그램의 렌더링을 운영체제 내부에서 새로하며, 그렇기에 창 크기를 자유롭게 조절하거나 크로마키와 마스크를 씌우는 등 고급 렌더링을 할 수 있으며 지원하는 경우 3D 렌더링 또한 가능하다.
    * 물론, 얘기했듯이 운영체제 내부에서 렌더링을 새로 하는 것이기에 외부 세계에는 전혀 영향 받지 않는다.\
      ~~다만 후킹 형식으로 렌더링을 가로채는거라 안티치트엔 걸릴 수도?~~
  * 호환성 모드를 활성화 하면, 창 관리를 수행하지 않기에 테마, 3D 렌더링, 창 크기 조절 같은것을 사용하지 못하나, 외부에서 렌더링 한 결과물을 그대로 운영체제로 출력하기에 호환성은 제일 좋다.
    * 예를 들어서 현실의 리눅스에서 실행된 프로그램을 호환성 모드로 불러왔다면, 리눅스에서 렌더링 된 창 자채를 있는 그대로 출력하여 창이 리눅스 테마로 보일 것이다.
  * 외부 세계의 운영체제에서 만들어졌지만, 실행 주체가 외부 세계의 운영체제가 아닌 내부 운영체제일 경우 어차피 운영체제 코드를 거치기에 후킹을 하지 않아도 되어 호환성 문제 또한 발생하지 않는다.

``RuniOS.SystemCallAttribute`` 사용 예시
```cs
using System;
using RuniOS;

/*
 * 커널은 일반적으론 평범한 메소드에 붙었을때 "Start", "Init" 같은 값이 메소드 이름이거나 입력되었다면 이를 명령 스레드에서 딱 한번 메소드를 실행한다.
 * 반대로 "Update", "Loop" 같은 값이 입력되면 운영체제의 Life-cycle에 종속되어 사용자나 커널이 취소할 때 까지 명령 스레드에서 틱 당 한번씩 무한히 실행한다.
 * 만약 extren 함수가 아니고, 클래스의 멤버이지만 정적 멤버는 아닐 경우엔 인스턴스가 생성될 때 실행한다.
 */
[SystemCall("Start")]
void WaSans()
{
  Console.WriteLine(calc);
  Console.WriteLine(OwnerInvoke());
  Asdf();
}

// 커널은 일반적으론 입력된 값이나 멤버 이름에 맞는 값을 반환하려 노력한다.
static extern double calc { [SystemCall("532.513 * 153.425 / 6341")] get; }
[SystemCall("놀아주라")] static extern string OwnerInvoke();

// 사용자한태 꼭 결과값을 알려줘야하거나 명령을 실행하는데 실패 했을 경우 (명령을 이해하지 못했거나 권한이 없다거나 등) 예외로 처리한다.
[SystemCall("shutdown")] static extern void Asdf();
```
```cs
/* 출력

12.8845303619303
루미두 놀고 싶지만... 지금은 마니 바빠..!

Unhandled exception. System.OperationCanceledException: 그리고.. 이건 무엇을 하고 싶은거야..?
   at Submission#0.<WaSans>d__0() in <8d5cc6388a0d2b4bdbcc56aadf0e80d7>:line 10
   at Submission#0.<Factory0>(Object $host, Object[] $args) in <8d5cc6388a0d2b4bdbcc56aadf0e80d7>:line 0

*/
```
... 사실 웬만하면 오너캐한태 ~~직접 가서 말하는게 더 나을 것이다.~~ 코드에서 오너캐의 능력이 필요한 것은 꽤 보기 드물 것\
보통 코드로 커널한태 접근할 수 있는 권한을 얻었다면, 그 전에 이미 오너캐랑 한번 이상은 만났을 것이기 때문\
그냥 이런 것도 있다~ 하는 정도?

## 주의 사항

세계관과 프로그램은 완전히 다른 취급이예요!

그러니까... 원신 "게임"을 운영체제에 로드한 것은, 우리가 현실에서 하는 실제 원신과 다른게 전혀 없어요!\
그 안의 캐릭터가 직접 말하거나 움직인다거나 하지 않는다는 거예요!

하지만 원신 "세계관"을 운영체제에 로드하는 것은 달라요.\
세계관을 로드하게 되면, 그 세게관에서 지내는 캐릭터는 스스로 생각하며 움직이고 대화도 가능하고,\
시스템도 실제 게임 규칙에 억매이지 않고 적재적소에 맞춰서 적절하게 동작해요!

시스템이란... 실제 게임에서는 클레가 스킬이 통통 폭탄 하나로 정해져있는 것을 넘어서 쿨타임이 있고,\
그 쿨타임이 지나기 전에는 무슨 수를 써도 불 원소를 사용할 수 없잖아요? ~~(클레 법구인데요? 라고 팩폭하지마잇)~~

하지만 세계관을 불러오면, 세계관 "설정"에 맞춰서\
클레가 스킬 쿨타임에 영향받지 않고 자유자재로 불 원소를 사용하고 폭탄도 던지고 할 수 있는거예요!

당연히! 원신의 세계관을 불러온 것이기 때문에,\
우리 또한 신의 눈이 있다면 자유자재로 원소를 사용할 수 있는 것은 덤이고요!

만약... 원신 세계관의 클레가 원신 게임의 클레를 본다면\
자기가 게임에 나온다고 엄청 좋아하겠네요ㅋㅋㅋ

하지만... **직접 로드된 프로그램 속으로 들어가게된다면** 그때부터는 일종의 세계관으로 취급되요.\
당연하게도... 그 게임 속으로 들어간다는 것 부터 일단 세계관이지 게임이 아니니까요?

## 세계관 혼합의 공식적인 예시

운영체재의 커널, 즉 루미라는 캐릭터는, 거의 대부분의 세계관에서 ~~(이론상)~~ 최강자로 의도된 캐릭터이지만, 저는 다른 세계관의 설정을 존중하고싶습니다.\
이에, 서로 다른 세계관을 병합할 때 병합 충돌이 발생할 수 있는 설정들의 경우 어떤식으로 병합 충돌이 해결되는지 예시를 보려주려고 합니다.\
물론 이는 제 개인적인 의견일 뿐, 강제적으로 적용되진 않는다는 점을 참고해주세요.

추가로 ROS 소속의 캐릭터가 상호작용하고 있는 세계관의 설정은 ROS의 세계관 설정보다 **우선적으로 적용된다는 점**을 기억해주세요.\
단, 현실 조작 관련 능력을 가진 캐릭터는 현실을 **조작하는 것이기에** 자유롭게 능력을 사용할 수 있습니다.

예를 들어서, 입으로 불을 뿜을 수 있는 능력의 캐릭터가 있고, 그 캐릭터는 불이라는 개념이 존재하지 않는 세계관과 상호작용할 경우 그 캐릭터는 불을 뿜을 수 없는 허접이 될 것 입니다.\
하지만, 그 능력이 현실 조작을 기반으로 이루어진 능력이라면 무시할 수 있습니다.

현실 조작이란 개념이 없는 세계의 경우, 현실 조작으로 현실 조작이란 개념이 없는 것을 조작했다 볼 수 있기에 현실 조작이 일반적으론 더 우선 됩니다.


### SCP Foundation

* 스크랜턴 현실성 닻
  * 커널, 즉 루미의 ~~Antinfinity Teleport라고 불리는~~ 긴급 텔레포트 능력을 제외한 **모든 능력**은 **현실 조작**을 기반으로 이루어진 능력이기에, 스크랜턴 현실성 닻의 영향 범위 내에서는 모든 능력을 사용할 수 없습니다.

  * 운영체제의 내부에 설치된 경우는 좀 특이하게 동작하는데, 운영체제 내부에서의 루미의 현실 조작은 운영체제, 즉 그 세계에선 **너무나 당연한 사건**이기에 **현실 조작으로 판정되지 않습니다.**
    * 하지만, 루미의 권한을 통해 부여받은 능력으로 규칙에서 벗어난것이 아닌 현실 조작이라면, 그 사건은 실제로 현실 조작으로 간주되기에 스크랜턴 현실성 닻의 영향 범위 내에서는 능력을 사용할 수 없게 됩니다.
  * 크샹크/아나스타사코스 일정불변 시간적 특이점 또한 비슷하게 작용합니다.
